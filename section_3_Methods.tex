\section{Methodology}
\label{sec:method}
In this paper, we designed a special purpose EMO algorithm which we call as Normalized Objectives' Sum Sorting Genetic Algorithm (NOSSGA). It optimizes three objectives, with certain attentions to the nature of the problem, and generates a tree-space that contains high quality species trees. 

We encode species tree using \textit{TreeTemplate} class provided by BIO++~\cite{gueguen2013bpp} which is a collection of C++ libraries for Bioinformatics. 

We also apply NSGAII, using the same crossover, mutation and initialization method as the NOSSGA, to approximate the PF by optimizing the three objectives. 
\begin{equation}\label{eqn:nos}
NOS(x) = \sum_{i=1}^{3} \frac{F_i(x)-z_i^{min}}{z_i^{max}-z_i^{min}}
\end{equation}
where $z_i^{min}$ ($z_i^{max}$) is the minimum (maximum) value of $i^{th}$ objective $F_i$ observed so far during the search process
\subsection{Evolutionary Algorithms}
\begin{algorithm}[!htbp]
	\scriptsize
	\caption{NOSSGA}
	\textbf{Input:} $G$ (max. generations), $N$ (population size), $C_r$ (crossover rate), $M_r$ (mutation rate), $T$ (Tournament size)\\
	\textbf{Output:} $P$ (A vector of $N$ species trees)
	\begin{algorithmic}[1]\label{alg:nossga}
		\STATE{Initialize $P$ with $N$ randomly generated solutions (i.e., species trees) }
		\STATE{For each solution in $ P $, evaluate the objective functions and $NOS()$} \COMMENT{all objectives are treated as minimization, $NOS()$ defined in eqn.\ref{eqn:nos}}
		%\STATE{For each solution $x$ in $ P $, calculate NOS($x$)}
		\STATE{$g \gets 0$} \COMMENT{geenration counter}
		\WHILE{ $g < G$}
			\STATE{$Q \gets \emptyset$} \COMMENT{an empty vector that can hold $N$ solutions}
			\FOR{$i \leftarrow 1$ to $N$}	%\label{mainLoop}	
				\STATE{$S_1 \gets$ tournament\_selection($P$),} \COMMENT{based on NOS()}
				\STATE{$S_2 \gets$ random\_selection($P$)}
				\STATE{$Q[i] \gets$ mutation(crossover($S_1, S_2$))}
				%\STATE{Generate an offspring by applying crossover on $S_1, S_2$, then mutate the offspring and append the resultant solution to $Q$}		
			\ENDFOR	
			\STATE{For each solution in $ Q $, evaluate the objective functions and $NOS()$ }
			\STATE{$ R \gets P \cup Q$} \COMMENT{$R$ is a vector of $2N$ solutions}
			%\STATE{For each solution $x$ in $ R $, calculate NOS($x$)}
			\STATE{Sort the members of $ R $ in ascending order of NOS} \COMMENT{as all objectives are minimization}
			\STATE{$P \gets \emptyset$, Append $R[1]$ to $P$, Remove $R[1]$ from $R$}
			%\STATE{$P[1] \gets R[1]$}
			%\STATE{$i \gets 2$}
			\FOR{$i \leftarrow 2$ to $N$}	%\label{mainLoop}	
				\STATE{\textbf{if} $NOS$($R[1]$) $\ne$ $NOS$(Current end of $P$), \textbf{then} Append $R[1]$ to $P$ }	
				\STATE{Remove $R[1]$ from $R$}	\COMMENT{each element is shifted left by 1 position }
			\ENDFOR	
%			\FOR{$i \gets 1$ to $N$}	%\label{mainLoop}	
%				\IF{ NOS($R[i]) \ge P[i-1]$)}
%					\STATE{$P[i] \gets R[i]$}
%				\ENDIF
%				\STATE{Remove $R[i]$ from $R$}		
%			\ENDFOR	
			\STATE{For each remaining solution in $ R $, calculate the crowding distance}
			\STATE{Sort the members of $ R $  in descending order of the crowding distance}
			\STATE{Fill-up the remaining solutions for $P$ from the top of $R$}
			\STATE{$g \gets g + 1$}
		\ENDWHILE
		\STATE{\textbf{return} $P$}
	\end{algorithmic}
\end{algorithm}
\subsection{Objective Evaluation}
ASTRAL, STELAR: java code
MP-EST: Maximize branch length, c++ code
\subsection{Crossover}
PDG
\subsection{Mutation}
NNI, SPR, TBR
\subsection{Solution Initialization}
Using crossover on randomly selected pairs of gene trees.