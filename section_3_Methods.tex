\section{Methodology}
\label{sec:method}
In this paper, we adapted NSGAII for species tree estimation by integrating problem-specific encoding, initialization, crossover and mutation. Moreover, we designed a special purpose EMO algorithm by modifying NSGAII considering issues associated with the problem mentioned in Section~\ref{sec:problem}. In this section, we discuss the design of our modified EMO algorithm along with its different components.


\subsection{Algorithm Design}
In general, any EMO algorithm can help to resolve issue~\ref{item:i1} by maintaining a population which contains some solutions having objectives values slightly below the domination threshold (Definition~\ref{def:domination_threshold}). But it allows optimizing one objective to a great extent even at the loss of others. Therefore, we modified NSGAII in a way that tackles issue~\ref{item:i1} more elegantly in addition to resolving issue~\ref{item:i2}.  

\begin{definition}\label{def:domination_threshold}
	\small
	We call the worst value along a particular objective in the obtained PF of a certain generation as the \textbf{domination threshold} for that objective at that generation.
\end{definition}

\begin{equation}\label{eqn:nos}
\small
NOS(x) = \sum_{i=1}^{3} \frac{F_i(x)-z_i^{min}}{z_i^{max}-z_i^{min}}
\end{equation}
{\scriptsize where $z_i^{min}$ ($z_i^{max}$) is the minimum (maximum) value of $i^{th}$ objective $F_i$ observed so far during the search process}

We replaced the non-dominated sorting by sorting based on the summation of normalized values all objective as defined by the $NOS()$ function shown in equation~\ref{eqn:nos}. That's why call the resultant algorithm as Normalized Objectives' Sum Sorting Genetic Algorithm (NOSSGA). Previously similar function was utilized in~\cite{qu2010multi}, while designing an EMO algorithm, to increase diversity and reduce computational complexity. The pseudo-code of NOSSGA in shown in Algorithm~\ref{alg:nossga}. We intensify the effect of $NOS()$ by using tournament selection based on $NOS()$ instead of the default binary tournament. We expect that selection based on $NOS()$ will discard those solutions which optimized one objective heavily at the cost of degrading others. This feature resolves issue~\ref{item:i1} more elegantly than NSGAII as well as address issue~\ref{item:i2} that NSGAII cannot handle. 

To maintain diversity of population, we always arbitrarily choose one from multiple solutions having the same $NOS()$ value (line \ref{line:diversity}). Like NSGAII, NOSSGA is a highly exploitative algorithm. To increase the exploration capability, we use crowding distance concept of NSGAII, albeit in a different way than NSGAII, to pick some least crowded solutions among the solutions with lower $NOS()$ values  (line~\ref{line:crowding_s}-\ref{line:crowding_e}). While generating offspring, we keep random selection in line~\ref{line:random_selection} to ensure the participation of such solutions. We expect that this feature will help to escape local optima.


%It optimizes three objectives, with certain attentions to the nature of the problem, and generates a tree-space that contains high quality species trees. 
%We also apply NSGAII, using the same crossover, mutation and initialization method as the NOSSGA, to approximate the PF by optimizing the three objectives. 

\begin{algorithm}[!htbp]
	\scriptsize
	\caption{NOSSGA}
	\textbf{Input:} $m_g$ (max. generations), $p_s$ (population size), $c_r$ (crossover rate), $m_r$ (mutation rate), $t_s$ (Tournament size)\\
	\textbf{Output:} $P$ (A vector of $N$ species trees)
	\begin{algorithmic}[1]\label{alg:nossga}
		\STATE{Initialize $P$ with $N$ randomly generated solutions (i.e., species trees) } \COMMENT{sec.~\ref{subsec:init}}
		\STATE{For each solution in $ P $, evaluate the objective functions and $NOS()$} \COMMENT{using eqn.\ref{eqn:nos}}
		%\STATE{For each solution $x$ in $ P $, calculate NOS($x$)}
		\STATE{$g \gets 0$} \COMMENT{generation counter}
		\WHILE{ $g < m_g$}
			\STATE{$Q \gets \emptyset$} \COMMENT{offspring population, an empty vector that can hold $N$ solutions}
			\FOR{$i \leftarrow 1$ to $p_s$}	%\label{mainLoop}	
				\STATE{$S_1 \gets$ tournament\_selection($P$, $t_s$)} \COMMENT{based on NOS()}
				\STATE{$S_2 \gets$ random\_selection($P$)} \label{line:random_selection}
				\STATE{$Q[i] \gets$ mutation(crossover($S_1, S_2, c_r$), $m_r$)} \COMMENT{sec.~\ref{subsec:crossver}, \ref{subsec:mutation}}
				%\STATE{Generate an offspring by applying crossover on $S_1, S_2$, then mutate the offspring and append the resultant solution to $Q$}		
			\ENDFOR	
			\STATE{For each solution in $ Q $, evaluate the objective functions and $NOS()$ }
			\STATE{$ R \gets P \cup Q$} \COMMENT{$R$ is a vector holding $2N$ solutions}
			%\STATE{For each solution $x$ in $ R $, calculate NOS($x$)}
			\STATE{Sort the members of $ R $ in ascending order of $NOS()$} \COMMENT{ascendind because all objectives are treated as minimization} \label{line:nos}
			\STATE{$P \gets \emptyset$, Append $R[1]$ to $P$, Remove $R[1]$ from $R$}
			%\STATE{$P[1] \gets R[1]$}
			%\STATE{$i \gets 2$}
			\FOR{$i \leftarrow 2$ to $p_s$}	%\label{mainLoop}	
				\STATE{\textbf{if} $NOS$($R[1]$) $\ne$ $NOS$(Current end of $P$), \textbf{then} Append $R[1]$ to $P$ }	\label{line:diversity}
				\STATE{Remove $R[1]$ from $R$}	\COMMENT{each element is shifted left by 1 position }
			\ENDFOR	
%			\FOR{$i \gets 1$ to $N$}	%\label{mainLoop}	
%				\IF{ NOS($R[i]) \ge P[i-1]$)}
%					\STATE{$P[i] \gets R[i]$}
%				\ENDIF
%				\STATE{Remove $R[i]$ from $R$}		
%			\ENDFOR	
			\STATE{For each remaining solution in $ R $, calculate the crowding distance}\label{line:crowding_s}
			\STATE{Sort the members of $ R $  in descending order of the crowding distance in $R$}
			\STATE{Fill-up the remaining solutions for $P$ from the top of $R$}\label{line:crowding_e}
			\STATE{$g \gets g + 1$}
		\ENDWHILE
		\STATE{\textbf{return} $P$}
	\end{algorithmic}
\end{algorithm}

\subsection{Crossover}\label{subsec:crossver}
We used Prune-Delete-Graft (PDG)~\cite{villalobos2018memetic} as the crossover operator which generates one tree (i.e., offspring) from two parents. At first, It takes a random sub-tree fromone of the parents. Then it inserts the selected sub-tree in the other parent at arandomly selected insertion point. Finally it deletes duplicated speciesfrom the second tree and returns it as the output.

\subsection{Mutation} \label{subsec:mutation}
Our mutation operator applies one of the three widely used tree rearrangement strategies~\cite{felsenstein2004inferring}: (i) Nearest NeighbourInterchange (NNI), (ii) Sub-tree Pruning and Re-grafting(SPR) and (iii) Tree Bisection and Reconnection (TBR). Each of them is selected randomly with equal probability. NNIexchanges sub-trees from an arbitrary internal branch to obtaina new tree. SPR picks a random sub-tree from a tree, removes it and then re-grafts it in a randomposition to generate a new tree. TBR combines bothSPR and NNI.

\subsection{Solution Initialization}\label{subsec:init}
We utilized the given set of gene trees initializing the population. We randomly pair two gene trees and apply our crossover operator on them to generate an initial solution


\subsection{Implementation Notes}
We encoded species tree using \textit{TreeTemplate} class provided by BIO++~\cite{gueguen2013bpp} which is a collection of C++ libraries for Bioinformatics. We implemented both NSGAII and NOSSGA using jMetalCpp\footnote{\url{https://github.com/jMetal/jMetalCpp}} which is a C++ framework for EMO. We used the implementation of PDG, NNI, SPR and TBR from~\cite{zambrano2016mo} after fixing several bugs. We evaluated each objective (QT/TP/PL) using a feature provided by each method (ASTRAL/STELAR/MP-EST) to score an existing species tree. Thus for each candidate solution, we invoked the executable of a particular method to evaluate an objective.

\begin{comment}
\subsection{Objective Evaluation}
Each method (ASTRAL, STELAR or MP-EST) provides an option to score an existing species tree. We used this feature enable to evaluate the objectives. Thus for each candidate species tree, we invoke the executable of a particular method (ASTRAL/STELAR/MP-EST) to evaluate an objective . %We converted each objective into minimization to conform 
%We evaluated each objective by executing the method that 
%: invoke java executable
%MP-EST: Maximize branch length, c++ executable
\end{comment}